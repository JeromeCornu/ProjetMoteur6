#version 330 core

layout(location = 0) in vec3 vertexPosition;
layout(location = 1) in vec2 vertexUV;
// layout(location = 2) in vec3 vertexColor;

vec3 Normal_cameraspace = vec3 (0.0f, 0.0f, 0.0f);
vec3 LightDirection_cameraspace = vec3 (0.0f, 0.0f, 0.0f);

vec4 gl_Position;
vec3 vertexPosition_modelspace = vec3 (0.0f, 0.0f, 0.0f);
vec3 Position_worldspace;
vec3 EyeDirection_cameraspace;
vec3 LightPosition_worldspace = vec3 (0.0f, 0.0f, 0.0f);
vec3 vertexNormal_modelspace = vec3 (0.0f, 0.0f, 0.0f);

// out vec3 fragmentColor;
out vec2 UV;

uniform mat4 MVP;
uniform mat4 Model;
uniform mat4 View;

void main()
{
  // gl_Position.xyz = vertexPosition;
  gl_Position =  MVP * vec4(vertexPosition, 1);
  // gl_Position.w = 1.0;

  UV = vertexUV;
  // fragmentColor = vertexColor;




  gl_Position =  MVP * vec4(vertexPosition_modelspace,1);

  Position_worldspace = (Model * vec4(vertexPosition_modelspace,1)).xyz;

 
  vec3 vertexPosition_cameraspace = ( View * Model * vec4(vertexPosition_modelspace,1)).xyz;
  EyeDirection_cameraspace = vec3(0,0,0) - vertexPosition_cameraspace;


  vec3 LightPosition_cameraspace = ( View * vec4(LightPosition_worldspace,1)).xyz;
  LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;


  Normal_cameraspace = ( View * Model * vec4(vertexNormal_modelspace,0)).xyz; // Only correct if ModelMatrix does not scale the model ! Use its inverse transpose if not.


}